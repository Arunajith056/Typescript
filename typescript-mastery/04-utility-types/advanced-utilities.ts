/**\n * Advanced Utility Types\n * Comprehensive examples of TypeScript's utility types and custom implementations\n */\n\n// ==================== BUILT-IN UTILITY TYPES ====================\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age?: number;\n  role: 'admin' | 'user' | 'moderator';\n}\n\n// Record - Creates object type with specific key-value types\ntype UserRoles = Record<string, 'admin' | 'user' | 'moderator'>;\nconst roles: UserRoles = {\n  'john': 'admin',\n  'jane': 'user',\n  'bob': 'moderator'\n};\n\n// Readonly - Makes all properties readonly\ntype ReadonlyUser = Readonly<User>;\nconst readonlyUser: ReadonlyUser = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  role: 'admin'\n};\n// readonlyUser.name = 'Jane'; // Error: Cannot assign to 'name'\n\n// Required - Makes all properties required\ntype RequiredUser = Required<User>;\nconst requiredUser: RequiredUser = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  age: 30, // Now required\n  role: 'admin'\n};\n\n// ==================== OBJECT TRANSFORMATION UTILITIES ====================\n\n// Exclude - Excludes types from union\ntype NonAdminRole = Exclude<User['role'], 'admin'>; // 'user' | 'moderator'\n\n// Extract - Extracts types from union\ntype AdminRole = Extract<User['role'], 'admin'>; // 'admin'\n\n// NonNullable - Removes null and undefined\ntype NonNullableString = NonNullable<string | null | undefined>; // string\n\n// ==================== CUSTOM UTILITY TYPE IMPLEMENTATIONS ====================\n\n// Custom Pick implementation\ntype MyPick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\ntype UserInfo = MyPick<User, 'name' | 'email'>;\n// { name: string; email: string; }\n\n// Custom Omit implementation\ntype MyOmit<T, K extends keyof T> = {\n  [P in keyof T]: P extends K ? never : T[P];\n}[keyof T];\n\ntype UserWithoutId = MyOmit<User, 'id'>;\n// { name: string; email: string; age?: number; role: 'admin' | 'user' | 'moderator'; }\n\n// ==================== ADVANCED TRANSFORMATION TYPES ====================\n\n// Mutable - Removes readonly from properties\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\ntype MutableUser = Mutable<ReadonlyUser>;\n// Properties are no longer readonly\n\n// Optional - Makes specific properties optional\ntype Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\ntype UserWithOptionalEmail = Optional<User, 'email'>;\n// { id: number; name: string; email?: string; age?: number; role: string; }\n\n// Nullable - Makes properties nullable\ntype Nullable<T> = {\n  [P in keyof T]: T[P] | null;\n};\n\ntype NullableUser = Nullable<User>;\n// All properties can be null\n\n// ==================== DEEP TRANSFORMATION UTILITIES ====================\n\n// DeepReadonly - Makes all properties readonly recursively\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\ninterface NestedUser {\n  profile: {\n    personal: {\n      firstName: string;\n      lastName: string;\n    };\n    contact: {\n      email: string;\n      phone: string;\n    };\n  };\n}\n\ntype DeepReadonlyNestedUser = DeepReadonly<NestedUser>;\n// All nested properties are readonly\n\n// DeepPartial - Makes all properties optional recursively\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\ntype DeepPartialNestedUser = DeepPartial<NestedUser>;\n// All nested properties are optional\n\n// ==================== CONDITIONAL UTILITY TYPES ====================\n\n// NonEmptyArray - Ensures array has at least one element\ntype NonEmptyArray<T> = [T, ...T[]];\n\nconst items: NonEmptyArray<string> = ['first']; // OK\nconst moreItems: NonEmptyArray<string> = ['first', 'second']; // OK\n// const empty: NonEmptyArray<string> = []; // Error\n\n// KeysOfType - Gets keys of properties with specific type\ntype KeysOfType<T, U> = {\n  [K in keyof T]: T[K] extends U ? K : never;\n}[keyof T];\n\ntype StringKeys = KeysOfType<User, string>; // 'name' | 'email'\ntype NumberKeys = KeysOfType<User, number>; // 'id'\n\n// ==================== FUNCTION UTILITY TYPES ====================\n\n// Parameters - Gets function parameter types\ntype UserFunction = (user: User, options: { save: boolean }) => Promise<User>;\ntype UserFunctionParams = Parameters<UserFunction>; // [User, { save: boolean }]\n\n// ReturnType - Gets function return type\ntype UserFunctionReturn = ReturnType<UserFunction>; // Promise<User>\n\n// ConstructorParameters - Gets constructor parameter types\nclass UserService {\n  constructor(private apiUrl: string, private timeout: number) {}\n}\n\ntype UserServiceParams = ConstructorParameters<typeof UserService>; // [string, number]\n\n// InstanceType - Gets instance type from constructor\ntype UserServiceInstance = InstanceType<typeof UserService>; // UserService\n\n// ==================== TEMPLATE LITERAL UTILITY TYPES ====================\n\n// Uppercase, Lowercase, Capitalize, Uncapitalize\ntype UppercaseName = Uppercase<'john'>; // 'JOHN'\ntype LowercaseName = Lowercase<'JOHN'>; // 'john'\ntype CapitalizedName = Capitalize<'john'>; // 'John'\ntype UncapitalizedName = Uncapitalize<'John'>; // 'john'\n\n// Custom string transformations\ntype CamelToSnake<T extends string> = T extends `${infer First}${infer Rest}`\n  ? First extends Uppercase<First>\n    ? `_${Lowercase<First>}${CamelToSnake<Rest>}`\n    : `${First}${CamelToSnake<Rest>}`\n  : T;\n\ntype SnakeName = CamelToSnake<'firstName'>; // '_first_name' (would need trimming)\n\n// ==================== MAPPED TYPE UTILITIES ====================\n\n// Getters - Creates getter functions for all properties\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// {\n//   getId: () => number;\n//   getName: () => string;\n//   getEmail: () => string;\n//   getAge: () => number | undefined;\n//   getRole: () => 'admin' | 'user' | 'moderator';\n// }\n\n// Setters - Creates setter functions for all properties\ntype Setters<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\ntype UserSetters = Setters<User>;\n// Setter functions for all properties\n\n// ==================== REAL-WORLD UTILITY EXAMPLES ====================\n\n// API Response wrapper\ntype ApiResponse<T> = {\n  data: T;\n  status: number;\n  message: string;\n  timestamp: Date;\n};\n\ntype UserResponse = ApiResponse<User>;\n\n// Database entity with timestamps\ntype WithTimestamps<T> = T & {\n  createdAt: Date;\n  updatedAt: Date;\n};\n\ntype UserEntity = WithTimestamps<User>;\n\n// Audit trail\ntype WithAudit<T> = T & {\n  createdBy: string;\n  updatedBy: string;\n  version: number;\n};\n\ntype AuditableUser = WithAudit<WithTimestamps<User>>;\n\n// ==================== VALIDATION UTILITY TYPES ====================\n\n// Form validation\ntype ValidationRule<T> = {\n  required?: boolean;\n  validator?: (value: T) => boolean | string;\n  message?: string;\n};\n\ntype FormValidation<T> = {\n  [K in keyof T]: ValidationRule<T[K]>;\n};\n\ntype UserFormValidation = FormValidation<User>;\n\n// Error handling\ntype ErrorMap<T> = {\n  [K in keyof T]?: string;\n};\n\ntype UserErrors = ErrorMap<User>;\n\n// ==================== STATE MANAGEMENT UTILITIES ====================\n\n// Redux-style actions\ntype ActionCreators<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => {\n    type: `SET_${Uppercase<string & K>}`;\n    payload: T[K];\n  };\n};\n\ntype UserActions = ActionCreators<User>;\n\n// Selectors\ntype Selectors<T> = {\n  [K in keyof T as `select${Capitalize<string & K>}`]: (state: { user: T }) => T[K];\n};\n\ntype UserSelectors = Selectors<User>;\n\n// ==================== EXAMPLE IMPLEMENTATIONS ====================\n\n// Example user with all utility types applied\nconst exampleUser: User = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  age: 30,\n  role: 'admin'\n};\n\nconst userInfo: UserInfo = {\n  name: exampleUser.name,\n  email: exampleUser.email\n};\n\nconst partialUser: Partial<User> = {\n  name: 'Updated Name'\n};\n\nconst userEntity: UserEntity = {\n  ...exampleUser,\n  createdAt: new Date(),\n  updatedAt: new Date()\n};\n\nconst auditableUser: AuditableUser = {\n  ...userEntity,\n  createdBy: 'system',\n  updatedBy: 'admin',\n  version: 1\n};\n\nconst apiResponse: UserResponse = {\n  data: exampleUser,\n  status: 200,\n  message: 'User retrieved successfully',\n  timestamp: new Date()\n};\n\n// Example validation schema\nconst userValidation: UserFormValidation = {\n  id: { required: true },\n  name: {\n    required: true,\n    validator: (value) => value.length >= 2 ? true : 'Name must be at least 2 characters'\n  },\n  email: {\n    required: true,\n    validator: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) || 'Invalid email format'\n  },\n  age: {\n    validator: (value) => value === undefined || (value >= 0 && value <= 120) || 'Age must be between 0 and 120'\n  },\n  role: { required: true }\n};\n\nconsole.log('Utility types examples:', {\n  userInfo,\n  userEntity,\n  auditableUser,\n  apiResponse,\n  validation: Object.keys(userValidation)\n});\n\nconsole.log('Advanced utility types loaded successfully!');\n\nexport {\n  roles,\n  readonlyUser,\n  requiredUser,\n  exampleUser,\n  userInfo,\n  partialUser,\n  userEntity,\n  auditableUser,\n  apiResponse,\n  userValidation\n};\n\nexport type {\n  UserRoles,\n  ReadonlyUser,\n  RequiredUser,\n  NonAdminRole,\n  AdminRole,\n  NonNullableString,\n  MyPick,\n  MyOmit,\n  UserInfo,\n  UserWithoutId,\n  Mutable,\n  Optional,\n  Nullable,\n  DeepReadonly,\n  DeepPartial,\n  NonEmptyArray,\n  KeysOfType,\n  Getters,\n  Setters,\n  ApiResponse,\n  WithTimestamps,\n  WithAudit,\n  ValidationRule,\n  FormValidation,\n  ErrorMap,\n  ActionCreators,\n  Selectors,\n  UserGetters,\n  UserSetters,\n  UserEntity,\n  AuditableUser,\n  UserFormValidation,\n  UserErrors,\n  UserActions,\n  UserSelectors\n};"